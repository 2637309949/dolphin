// Code generated by dol build. Only Generate by tools if not existed.
// source: ami.go

package srv

import (
	"ami/model"
	"encoding/json"
	"fmt"
	"time"

	"github.com/2637309949/dolphin/packages/ami"
	"github.com/2637309949/dolphin/packages/gin"
	"github.com/2637309949/dolphin/packages/logrus"
	"github.com/2637309949/dolphin/packages/redis"
	"github.com/2637309949/dolphin/packages/xormplus/xorm"
	"github.com/go-errors/errors"
)

type errorLogger struct{}

func (l *errorLogger) AmiError(err error) {
	println("Got error from Ami:", err.Error())
}

// AmiProducerConn defined
var AmiProducerConn *ami.Producer

// AmiConsumerConn defined
var AmiConsumerConn *ami.Consumer

func init() {
	var err error
	AmiProducerConn, err = ami.NewProducer(
		ami.ProducerOptions{
			Name:              "ami",
			ErrorNotifier:     &errorLogger{},
			PendingBufferSize: 10000000,
			PipeBufferSize:    50000,
			PipePeriod:        time.Microsecond * 1000,
			ShardsCount:       10,
		},
		&redis.Options{
			Addr:         ":6379",
			ReadTimeout:  time.Second * 60,
			WriteTimeout: time.Second * 60,
		},
	)
	if err != nil {
		panic(err)
	}

	AmiConsumerConn, err = ami.NewConsumer(
		ami.ConsumerOptions{
			Name:              "ami",
			Consumer:          "ami",
			ErrorNotifier:     &errorLogger{},
			PendingBufferSize: 10000000,
			PipeBufferSize:    50000,
			PipePeriod:        time.Microsecond * 1000,
			PrefetchCount:     100,
			ShardsCount:       10,
		},
		&redis.Options{
			Addr:         ":6379",
			ReadTimeout:  time.Second * 60,
			WriteTimeout: time.Second * 60,
		},
	)
	if err != nil {
		panic(err)
	}
}

// AmiProducer defined srv
func AmiProducer(ctx *gin.Context, db *xorm.Engine, params model.AmiInfo) (interface{}, error) {
	aiStr, err := json.Marshal(params)
	if err != nil {
		logrus.Error("failed to marshal:", err)
		return nil, err
	}
	AmiProducerConn.Send(string(aiStr))
	return nil, nil
}

// AmiConsumer defined srv
func AmiConsumer(ctx *gin.Context, db *xorm.Engine, params map[string]interface{}) (interface{}, error) {
	defer func() {
		if err := recover(); err != nil {
			goErr := errors.Wrap(err.(error), 3)
			fmt.Print(string(goErr.Stack()))
		}
	}()
	c := AmiConsumerConn.Start()
	var items []model.AmiInfo
	quit := make(chan bool)
	go func() {
		for {
			select {
			case m, more := <-c:
				if !more {
					AmiConsumerConn.Stop()
					quit <- true
				}
				AmiConsumerConn.Ack(m)
				value := model.AmiInfo{}
				if err := json.Unmarshal([]byte(m.Body), &value); err != nil {
					logrus.Error("failed to unmarshal:", err)
				}
				items = append(items, value)
			case <-time.After(3 * time.Second):
				quit <- true
			}
		}
	}()
	<-quit
	return items, nil
}
