// Code generated by dol build. Only Generate by tools if not existed, your can rewrite platform.App default action
// source: app.go

package app

import (
	"path"
	"strings"
	"sync"
	"time"

	"github.com/2637309949/dolphin/platform/app"
	"github.com/2637309949/dolphin/platform/util"
)

type (
	// HandlerFunc defined
	HandlerFunc func(ctx *Context)
	// HandlersChain defined
	HandlersChain []HandlerFunc
	// Engine defined parse app engine
	Engine struct {
		RouterGroup
		*app.Engine
		pool sync.Pool
	}
	// Context defined http handle hook context
	Context struct {
		*app.Context
		engine *Engine
	}
	// RouterGroup defines struct that extend from gin.RouterGroup
	RouterGroup struct {
		engine   *Engine
		Handlers []HandlerFunc
		basePath string
	}
)

func (e *Engine) allocateContext() *Context {
	return &Context{engine: e}
}

// HandlerFunc convert to app.HandlerFunc
func (e *Engine) HandlerFunc(h HandlerFunc) (phf app.HandlerFunc) {
	return app.HandlerFunc(func(ctx *app.Context) {
		c := e.pool.Get().(*Context)
		c.Context = ctx
		h(c)
		e.pool.Put(c)
	})
}

// Handle overwrite RouterGroup.Handle
func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) {
	for i, methods := 0, strings.Split(httpMethod, ","); i < len(methods); i++ {
		method := methods[i]
		absPath := path.Join(group.basePath, relativePath)
		hls := []app.HandlerFunc{}
		for j := 0; j < len(handlers); j++ {
			hls = append(hls, group.engine.HandlerFunc(handlers[j]))
		}
		group.engine.Http.Handle(method, absPath, hls...)
	}
}

func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain {
	finalSize := len(group.Handlers) + len(handlers)
	if finalSize >= int(63) {
		panic("too many handlers")
	}
	mergedHandlers := make(HandlersChain, finalSize)
	copy(mergedHandlers, group.Handlers)
	copy(mergedHandlers[len(group.Handlers):], handlers)
	return mergedHandlers
}

func (group *RouterGroup) calculateAbsolutePath(relativePath string) string {
	if relativePath == "" {
		return group.basePath
	}

	finalPath := path.Join(group.basePath, relativePath)
	if util.LastChar(relativePath) == '/' && util.LastChar(finalPath) != '/' {
		return finalPath + "/"
	}
	return finalPath
}

func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup {
	return &RouterGroup{
		Handlers: group.combineHandlers(handlers),
		basePath: group.calculateAbsolutePath(relativePath),
		engine:   group.engine,
	}
}

// Auth middles
func Auth(auth ...string) HandlerFunc {
	return func(ctx *Context) {
		app.Auth(auth...)(ctx.Context)
	}
}

// Roles middles
func Roles(roles ...string) HandlerFunc {
	return func(ctx *Context) {
		app.Roles(roles...)(ctx.Context)
	}
}

// Cache middles
func Cache(time time.Duration) HandlerFunc {
	return func(ctx *Context) {
		app.Cache(time)(ctx.Context)
	}
}

// NewEngine defined init engine you can custom engine
func NewEngine() *Engine {
	e := &Engine{
		Engine: app.App,
		RouterGroup: RouterGroup{
			Handlers: nil,
			basePath: "/",
		},
	}
	e.pool.New = func() interface{} { return e.allocateContext() }
	e.RouterGroup.engine = e
	return e
}

var (
	// App instance
	App = NewEngine()
	// Run defined
	Run = App.Run
)

func init() {
	SyncModel(App)
	SyncController(App)
	SyncService(App)
}
