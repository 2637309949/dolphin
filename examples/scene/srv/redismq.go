// Code generated by dol build. Only Generate by tools if not existed.
// source: redismq.go

package srv

import (
	"context"
	"encoding/json"
	"fmt"
	"scene/model"
	"time"

	"github.com/2637309949/dolphin/packages/redismq"
	"github.com/2637309949/dolphin/packages/xormplus/xorm"
	"github.com/gin-gonic/gin"
	"github.com/go-errors/errors"
	"github.com/go-redis/redis/v8"
	"github.com/sirupsen/logrus"
)

type errorLogger struct{}

func (l *errorLogger) AmiError(err error) {
	println("Got error from Ami:", err.Error())
}

// AmiProducerConn defined
var AmiProducerConn *redismq.Producer

// AmiConsumerConn defined
var AmiConsumerConn *redismq.Consumer

func init() {
	var err error
	AmiProducerConn, err = redismq.NewProducer(
		redismq.ProducerOptions{
			Name:              "ami",
			ErrorNotifier:     &errorLogger{},
			PendingBufferSize: 10000000,
			PipeBufferSize:    50000,
			PipePeriod:        time.Microsecond * 1000,
			ShardsCount:       10,
		},
		&redis.Options{
			Addr:         ":6379",
			ReadTimeout:  time.Second * 60,
			WriteTimeout: time.Second * 60,
		},
	)
	if err != nil {
		panic(err)
	}
	AmiConsumerConn, err = redismq.NewConsumer(
		redismq.ConsumerOptions{
			Name:              "ami",
			Consumer:          "ami",
			ErrorNotifier:     &errorLogger{},
			PendingBufferSize: 10000000,
			PipeBufferSize:    50000,
			PipePeriod:        time.Microsecond * 1000,
			PrefetchCount:     100,
			ShardsCount:       10,
		},
		&redis.Options{
			Addr:         ":6379",
			ReadTimeout:  time.Second * 60,
			WriteTimeout: time.Second * 60,
		},
	)
	if err != nil {
		panic(err)
	}
}

// AmiProducer defined srv
func AmiProducer(ctx *gin.Context, db *xorm.Engine, params model.AmiInfo) (interface{}, error) {
	aiStr, err := json.Marshal(params)
	if err != nil {
		logrus.Error("failed to marshal:", err)
		return nil, err
	}
	AmiProducerConn.Send(string(aiStr))
	return nil, nil
}

// AmiConsumer defined srv
func AmiConsumer(ctx *gin.Context, db *xorm.Engine, params map[string]interface{}) (interface{}, error) {
	defer func() {
		if err := recover(); err != nil {
			goErr := errors.Wrap(err.(error), 3)
			fmt.Print(string(goErr.Stack()))
		}
	}()
	var items []model.AmiInfo
	c := AmiConsumerConn.Start()
	cwt, cancel := context.WithCancel(context.TODO())
	go func(cwt context.Context) {
		for {
			select {
			case m, ok := <-c:
				if !ok {
					cancel()
					return
				}
				AmiConsumerConn.Ack(m)
				value := model.AmiInfo{}
				if err := json.Unmarshal([]byte(m.Body), &value); err != nil {
					logrus.Error("failed to unmarshal:", err)
				}
				items = append(items, value)
			case <-time.After(3 * time.Second):
				cancel()
				return
			}
		}
	}(cwt)
	<-cwt.Done()
	// AmiConsumerConn.Stop()
	return items, nil
}
