// Code generated by dol build. Only Generate by tools if not existed.
// source: dtm.go

package api

import (
	"fmt"
	"scene/types"

	"github.com/2637309949/dolphin/platform/util/reflect"
	"github.com/sirupsen/logrus"
)

// DtmTcc api implementation
// @Summary tcc
// @Tags dtm controller
// @Produce application/json
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/dtm/tcc [get]
func (ctr *Dtm) DtmTcc(ctx *Context) {
	q := ctx.TypeQuery()
	q.Value()
	ret, err := ctr.Srv.Trans(ctx, ctx.DB, struct{}{})
	if err != nil {
		logrus.Error(err)
		ctx.Fail(err)
		return
	}
	ctx.Success(ret)
}

// DtmTransOut api implementation
// @Summary trans_out
// @Tags dtm controller
// @Accept application/json
// @Produce application/json
// @Param trans_req body types.TransReq false "交易信息"
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/dtm/trans_out [post]
func (ctr *Dtm) DtmTransOut(ctx *Context) {
	var payload types.TransReq
	if err := ctx.ShouldBindWith(&payload); err != nil {
		logrus.Error(err)
		ctx.Fail(err)
		return
	}
	ret, dbr := ctx.BusinessDB("localhost").SQL("update user_account_trading t join user_account a on t.user_id=a.user_id and t.user_id=? set t.trading_balance=t.trading_balance + ? where a.balance + t.trading_balance + ? >= 0", 1, -payload.Amount.Int64, -payload.Amount.Int64).Execute()
	ra, _ := ret.RowsAffected()
	if dbr == nil && ra == 0 { // 如果余额不足，返回错误
		ctx.JSON(500, map[string]interface{}{"code": 500, "message": fmt.Errorf("update error, balance not enough")})
	}
	ctx.JSON(200, map[string]interface{}{
		"dtm_result": reflect.OrOne(payload.TransInResult.String, "SUCCESS").(string),
	})
}

// DtmTransOutConfirm api implementation
// @Summary trans_out_confirm
// @Tags dtm controller
// @Accept application/json
// @Produce application/json
// @Param trans_req body types.TransReq false "交易信息"
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/dtm/trans_out_confirm [post]
func (ctr *Dtm) DtmTransOutConfirm(ctx *Context) {
	var payload types.TransReq
	if err := ctx.ShouldBindWith(&payload); err != nil {
		logrus.Error(err)
		ctx.Fail(err)
		return
	}
	// 将原先冻结的资金记录解冻
	ret, dbr := ctx.BusinessDB("localhost").SQL("update user_account_trading t join user_account a on t.user_id=a.user_id and t.user_id=? set t.trading_balance=t.trading_balance + ?", 1, payload.Amount.Int64).Execute()
	ra, _ := ret.RowsAffected()
	if dbr == nil && ra == 0 { // 如果余额不足，返回错误
		ctx.JSON(500, map[string]interface{}{"code": 500, "message": fmt.Errorf("update error, balance not enough")})
	}
	dtmRet := "SUCCESS"
	if payload.TransInResult.String != "" {
		dtmRet = payload.TransInResult.String
	}
	ctx.JSON(200, map[string]interface{}{"dtm_result": dtmRet})
}

// DtmTransOutRevert api implementation
// @Summary trans_out_revert
// @Tags dtm controller
// @Accept application/json
// @Produce application/json
// @Param trans_req body types.TransReq false "交易信息"
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/dtm/trans_out_revert [post]
func (ctr *Dtm) DtmTransOutRevert(ctx *Context) {
	var payload types.TransReq
	if err := ctx.ShouldBindWith(&payload); err != nil {
		logrus.Error(err)
		ctx.Fail(err)
		return
	}
	// 幂等、悬挂处理
	ret, dbr := ctx.BusinessDB("localhost").SQL("update user_account_trading t join user_account a on t.user_id=a.user_id and t.user_id=? set t.trading_balance=t.trading_balance + ? where a.balance + t.trading_balance + ? >= 0", 1, payload.Amount.Int64, payload.Amount.Int64).Execute()
	ra, _ := ret.RowsAffected()
	if dbr == nil && ra == 0 { // 如果余额不足，返回错误
		ctx.JSON(500, map[string]interface{}{"code": 500, "message": fmt.Errorf("update error, balance not enough")})
	}
	dtmRet := "SUCCESS"
	if payload.TransInResult.String != "" {
		dtmRet = payload.TransInResult.String
	}
	ctx.JSON(200, map[string]interface{}{"dtm_result": dtmRet})
}

// DtmTransIn api implementation
// @Summary trans_in
// @Tags dtm controller
// @Accept application/json
// @Produce application/json
// @Param trans_req body types.TransReq false "交易信息"
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/dtm/trans_in [post]
func (ctr *Dtm) DtmTransIn(ctx *Context) {
	var payload types.TransReq
	if err := ctx.ShouldBindWith(&payload); err != nil {
		logrus.Error(err)
		ctx.Fail(err)
		return
	}
	ret, dbr := ctx.BusinessDB("localhost").SQL("update user_account_trading t join user_account a on t.user_id=a.user_id and t.user_id=? set t.trading_balance=t.trading_balance + ? where a.balance + t.trading_balance + ? >= 0", 2, payload.Amount.Int64, payload.Amount.Int64).Execute()
	ra, _ := ret.RowsAffected()
	if dbr == nil && ra == 0 { // 如果余额不足，返回错误
		ctx.JSON(500, map[string]interface{}{"code": 500, "message": fmt.Errorf("update error, balance not enough")})
	}
	dtmRet := "SUCCESS"
	if payload.TransInResult.String != "" {
		dtmRet = payload.TransInResult.String
	}
	ctx.JSON(200, map[string]interface{}{"dtm_result": dtmRet})
}

// DtmTransInConfirm api implementation
// @Summary trans_in_confirm
// @Tags dtm controller
// @Accept application/json
// @Produce application/json
// @Param trans_req body types.TransReq false "交易信息"
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/dtm/trans_in_confirm [post]
func (ctr *Dtm) DtmTransInConfirm(ctx *Context) {
	var payload types.TransReq
	if err := ctx.ShouldBindWith(&payload); err != nil {
		logrus.Error(err)
		ctx.Fail(err)
		return
	}
	// 将原先冻结的资金记录解冻
	ret, dbr := ctx.BusinessDB("localhost").SQL("update user_account_trading t join user_account a on t.user_id=a.user_id and t.user_id=? set t.trading_balance=t.trading_balance + ?", 2, -payload.Amount.Int64).Execute()
	ra, _ := ret.RowsAffected()
	if dbr == nil && ra == 0 { // 如果余额不足，返回错误
		ctx.JSON(500, map[string]interface{}{"code": 500, "message": fmt.Errorf("update error, balance not enough")})
	}
	dtmRet := "SUCCESS"
	if payload.TransInResult.String != "" {
		dtmRet = payload.TransInResult.String
	}
	ctx.JSON(200, map[string]interface{}{"dtm_result": dtmRet})
}

// DtmTransInRevert api implementation
// @Summary trans_in_revert
// @Tags dtm controller
// @Accept application/json
// @Produce application/json
// @Param trans_req body types.TransReq false "交易信息"
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/dtm/trans_in_revert [post]
func (ctr *Dtm) DtmTransInRevert(ctx *Context) {
	var payload types.TransReq
	if err := ctx.ShouldBindWith(&payload); err != nil {
		logrus.Error(err)
		ctx.Fail(err)
		return
	}
	// 幂等、悬挂处理
	ret, dbr := ctx.BusinessDB("localhost").SQL("update user_account_trading t join user_account a on t.user_id=a.user_id and t.user_id=? set t.trading_balance=t.trading_balance + ? where a.balance + t.trading_balance + ? >= 0", 2, -payload.Amount.Int64, payload.Amount.Int64).Execute()
	ra, _ := ret.RowsAffected()
	if dbr == nil && ra == 0 { // 如果余额不足，返回错误
		ctx.JSON(500, map[string]interface{}{"code": 500, "message": fmt.Errorf("update error, balance not enough")})
	}
	dtmRet := "SUCCESS"
	if payload.TransInResult.String != "" {
		dtmRet = payload.TransInResult.String
	}
	ctx.JSON(200, map[string]interface{}{"dtm_result": dtmRet})
}
