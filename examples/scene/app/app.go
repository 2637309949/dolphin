// Code generated by dol build. Only Generate by tools if not existed, your can rewrite platform.App default action
// source: app.go

package app

import (
	"sync"
	"time"

	"github.com/2637309949/dolphin/packages/gin"
	"github.com/2637309949/dolphin/packages/go-funk"
	pApp "github.com/2637309949/dolphin/platform/app"
)

type (
	// Engine defined parse app engine
	Engine struct {
		*pApp.Engine
		pool sync.Pool
	}
	// Context defined http handle hook context
	Context struct {
		*pApp.Context
		engine *Engine
	}
	// RouterGroup defines struct that extend from gin.RouterGroup
	RouterGroup struct {
		*pApp.RouterGroup
		engine *Engine
	}
	// HandlerFunc defines the handler used by gin middleware as return value
	HandlerFunc struct {
		Method       string
		RelativePath string
		Interceptor  []HandlerFunc
		Handler      func(ctx *Context)
	}
)

// HF2Handler defined
func HF2Handler(h func(ctx *Context)) HandlerFunc {
	return HandlerFunc{Handler: h}
}

func (e *Engine) allocateContext() *Context {
	return &Context{engine: e}
}

// Group handlers
func (e *Engine) Group(relativePath string, handlers ...gin.HandlerFunc) *RouterGroup {
	return &RouterGroup{engine: e, RouterGroup: e.Engine.Group(relativePath, handlers...)}
}

// HandlerFunc convert to pApp.HandlerFunc
func (e *Engine) HandlerFunc(h HandlerFunc) (phf pApp.HandlerFunc) {
	return pApp.HF2Handler(func(ctx *pApp.Context) {
		c := e.pool.Get().(*Context)
		c.Context = ctx
		h.Handler(c)
		e.pool.Put(c)
	})
}

// Handle overwrite RouterGroup.Handle
func (rg *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) []gin.IRoutes {
	return rg.RouterGroup.Handle(httpMethod, relativePath, funk.Chain(handlers).Map(func(h HandlerFunc) []pApp.HandlerFunc {
		ic := funk.Chain(h.Interceptor).Map(func(h HandlerFunc) pApp.HandlerFunc { return rg.engine.HandlerFunc(h) }).Value().([]pApp.HandlerFunc)
		return append(ic, rg.engine.HandlerFunc(h))
	}).FlattenDeep().Value().([]pApp.HandlerFunc)...)
}

// Auth middles
func Auth(auth ...string) HandlerFunc {
	return HF2Handler(func(ctx *Context) {
		pApp.Auth(auth...).Handler(ctx.Context)
	})
}

// Roles middles
func Roles(roles ...string) HandlerFunc {
	return HF2Handler(func(ctx *Context) {
		pApp.Roles(roles...).Handler(ctx.Context)
	})
}

// Cache middles
func Cache(time time.Duration) HandlerFunc {
	return HF2Handler(func(ctx *Context) {
		pApp.Cache(time).Handler(ctx.Context)
	})
}

// buildEngine defined init engine you can custom engine
// if you need
func buildEngine() *Engine {
	e := &Engine{Engine: pApp.App}
	e.pool.New = func() interface{} { return e.allocateContext() }
	return e
}

// Run app
func Run() {
	App.Run()
}

var (
	_ *Engine = &Engine{}
	// App instance
	App = buildEngine()
	// AuthToken by token
	AuthToken = Auth("token")
	// AuthEncrypt by encrypt
	AuthEncrypt = Auth("encrypt")
)

// SyncMiddle defined
func SyncMiddle() {
}

func init() {
	SyncMiddle()
	SyncModel()
	SyncController()
	SyncService()
}
