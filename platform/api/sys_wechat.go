// Code generated by dol build. Only Generate by tools if not existed.
// source: sys_wechat.go

package api

import (
	"errors"
	"net/url"
	"time"

	"github.com/2637309949/dolphin/packages/logrus"
	"github.com/2637309949/dolphin/packages/null"
	"github.com/2637309949/dolphin/platform/types"
)

// SysWechatOauth2 api implementation
// @Summary 授权回调
// @Tags 微信
// @Produce application/json
// @Failure 403 {object} types.Fail
// @Success 200 {object} types.Success
// @Failure 500 {object} types.Fail
// @Router /api/sys/wechat/oauth2 [get]
func (ctr *SysWechat) SysWechatOauth2(ctx *Context) {
	q := ctx.TypeQuery()
	q.SetString("code")
	q.SetString("state")

	state := q.GetString("state")
	sri, err := url.ParseQuery(state)
	if err != nil {
		logrus.Error(ctx, err)
		ctx.Fail(err)
		return
	}

	redirect_uri := sri.Get("redirect_uri")
	uuid := sri.Get("uuid")
	domain := sri.Get("domain")
	qrAuth := types.QrAuth{}
	err = CacheStore.Get("wechat:qrcode:"+uuid, &qrAuth)
	if err == nil {
		logrus.Error(ctx, errors.New("invalid qrcode"))
		ctx.Fail(errors.New("invalid qrcode"))
		return
	}

	db := App.Manager.GetBusinessDB(domain)
	if db == nil {
		ctx.Fail(errors.New("invalid domain"))
		return
	}

	user, err := ctr.Srv.WinXinBindCheck(ctx, App.PlatformDB, db, domain, q.GetString("code"))
	if err != nil {
		logrus.Error(ctx, err)
		ctx.Fail(err)
		return
	}

	qrAuth.RedirectUri = null.StringFrom(redirect_uri)
	qrAuth.Domain = null.StringFrom(domain)
	qrAuth.UserId = user.ID
	err = CacheStore.Set("wechat:qrcode:"+uuid, qrAuth, 30*time.Second)
	if err != nil {
		logrus.Error(ctx, err)
		ctx.Fail(err)
		return
	}
	ctx.Success("success")
}
