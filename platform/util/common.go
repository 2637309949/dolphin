// Code generated by dol build. Only Generate by tools if not existed.
// source: app.go

package util

import (
	"fmt"
	"math/rand"
	"net"
	"net/http"
	"os"
	"reflect"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/2637309949/dolphin/platform/util/slice"
	"github.com/gin-gonic/gin"
	"github.com/go-errors/errors"
	"github.com/sirupsen/logrus"
)

// M defined
type M map[string]interface{}

// RandType defined rand type
type RandType int

// RandType defined
const (
	RandNum RandType = iota
	RandNumUperChar
	RandNumChar
)

// RandString defined random char
func RandString(randLen int, randType RandType) string {
	randUint := make([]byte, randLen)
	rand.Seed(time.Now().UnixNano())
	switch randType {
	case RandNum:
		for i := 0; i < randLen; i++ {
			randUint[i] = uint8(48 + rand.Intn(10))
		}
	case RandNumUperChar:
		for i := 0; i < randLen; i++ {
			r := rand.Intn(36)
			switch {
			case r < 10:
				randUint[i] = uint8(48 + r)
			case r < 36:
				randUint[i] = uint8(55 + r)
			}
		}
	case RandNumChar:
		for i := 0; i < randLen; i++ {
			r := rand.Intn(62)
			switch {
			case r < 10:
				randUint[i] = uint8(48 + r)
			case r < 36:
				randUint[i] = uint8(55 + r)
			case r < 62:
				randUint[i] = uint8(61 + r)
			}
		}
	}
	return string(randUint)
}

// RandomInt generates a random int, based on a min and max values
func RandomInt(min, max int) int {
	return min + rand.Intn(max-min)
}

// EnsureLeft defined return left
func EnsureLeft(left interface{}, err error) interface{} {
	if err != nil {
		panic(fmt.Errorf("%v\n%v", err, string(errors.Wrap(err, 2).Stack())))
	}
	return left
}

// EnsureRight defined return right
func EnsureRight(err error, right interface{}) interface{} {
	if err != nil {
		panic(fmt.Errorf("%v\n%v", err, string(errors.Wrap(err, 2).Stack())))
	}
	return right
}

// SetFormatter defined
func SetFormatter(isTerminal bool) {
	logrus.SetFormatter(&logrus.TextFormatter{
		FullTimestamp:   true,
		DisableQuote:    true,
		ForceColors:     true,
		TimestampFormat: "02/01 15:04:05",
	})
}

// UserHomeDir defined
func UserHomeDir() string {
	if runtime.GOOS == "windows" {
		home := os.Getenv("HOMEDRIVE") + os.Getenv("HOMEPATH")
		if home == "" {
			home = os.Getenv("USERPROFILE")
		}
		return home
	}
	return os.Getenv("HOME")
}

// DeepSearch scans deep maps, following the key indexes listed in the
func DeepSearch(m map[string]interface{}, path []string) map[string]interface{} {
	for _, k := range path {
		m2, ok := m[k]
		if !ok {
			// intermediate key does not exist
			// => create it and continue from there
			m3 := make(map[string]interface{})
			m[k] = m3
			m = m3
			continue
		}
		m3, ok := m2.(map[string]interface{})
		if !ok {
			m3 = make(map[string]interface{})
			m[k] = m3
		}
		m = m3
	}
	return m
}

// SomeOne defined
func SomeOne(srv interface{}, def interface{}) interface{} {
	sliceValue := reflect.Indirect(reflect.ValueOf(srv))
	if sliceValue.Kind() == reflect.Slice {
		size := sliceValue.Len()
		if size <= 0 {
			return def
		}
		return sliceValue.Index(0).Interface()
	}
	return def
}

// LastChar defined
func LastChar(str string) uint8 {
	if str == "" {
		panic("The length of the string can't be 0")
	}
	return str[len(str)-1]
}

// JoinObject defined TODO
func JoinObject(arr interface{}, format ...string) (str string) {
	if !slice.IsIteratee(arr) {
		panic("First parameter must be an iteratee")
	}

	var (
		ft = "%v"
	)
	if len(format) > 0 {
		ft = format[0]
	}

	var (
		arrValue = reflect.ValueOf(arr)
		arrType  = arrValue.Type()
	)
	kind := arrType.Kind()

	if kind == reflect.Slice || kind == reflect.Array {
		for i := 0; i < arrValue.Len(); i++ {
			if str != "" {
				str += ","
			}
			str += fmt.Sprintf(ft, arrValue.Index(i).Interface())
		}
	}
	return str
}

// JsonCheck defined TODO
func JsonCheck(req *http.Request) bool {
	jsonType := "application/json"
	if req.ContentLength > 0 && strings.Contains(req.Header.Get("Content-Type"), jsonType) {
		return true
	}
	return false
}

// UriCheck defined TODO
func UriCheck(params gin.Params) bool {
	return len(params) > 0
}

// QueryCheck defined TODO
func QueryCheck(req *http.Request) bool {
	return req.Method == http.MethodGet || req.Method == http.MethodDelete
}

// IsPrivate defined TODO
func IsPrivate(ip net.IP) bool {
	if ip4 := ip.To4(); ip4 != nil {
		return ip4[0] == 10 ||
			(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||
			(ip4[0] == 192 && ip4[1] == 168)
	}
	return len(ip) == 16 && ip[0]&0xfe == 0xfc
}

// IsIp defined TODO
func IsIp(addr string) bool {
	reg := regexp.MustCompile(`[0-9]*.[0-9]*.[0-9]*.[0-9]*`)
	return reg.MatchString(addr)
}
