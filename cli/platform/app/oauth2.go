// Code generated by dol build. Only Generate by tools if not existed.
// source: oauth2.go

package app

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/2637309949/dolphin/cli/packages/null"
	oaErrors "github.com/2637309949/dolphin/cli/packages/oauth2/errors"
	"github.com/2637309949/dolphin/cli/platform/model"
	"github.com/go-session/session"
	"github.com/spf13/viper"
	"golang.org/x/oauth2"
)

// Oauth2 struct
type Oauth2 struct {
	*Engine
}

// BuildOauth2 return Oauth2
func BuildOauth2(build func(*Oauth2)) func(engine *Engine) {
	return BuildEngine(func(engine *Engine) {
		build(&Oauth2{Engine: engine})
	})
}

// Login api implementation
// @Summary 登录信息
// @Tags OAuth授权
// @Accept application/json
// @Param Authorization header string true "认证令牌"
// @Param user body model.User false "用户信息"
// @Failure 403 {object} model.Response
// @Router /api/oauth2/login [post]
func (ctr *Oauth2) Login(ctx *Context) {
	store, err := session.Start(nil, ctx.Writer, ctx.Request)
	if err != nil {
		ctx.Fail(err)
		return
	}
	ctx.Request.ParseForm()
	f := ctx.Request.Form
	domain := f.Get("domain")
	username := f.Get("username")
	password := f.Get("password")
	account := model.User{
		Name:   null.StringFrom(username),
		Domain: null.StringFrom(domain),
	}
	ext, err := ctr.PlatformDB.Where("delete_time is null").Get(&account)
	if err != nil {
		ctx.Fail(err)
		return
	}
	if !ext || !account.ValidPassword(password) {
		ctx.Fail(oaErrors.ErrInvalidGrant)
		return
	}
	store.Set("LoggedInUserID", account.ID.String)
	store.Set("LoggedInDomain", account.Domain.String)
	store.Save()
	ctx.Redirect(http.StatusFound, viper.GetString("oauth.auth"))
}

// Affirm api implementation
// @Summary 用户授权
// @Tags OAuth授权
// @Accept application/json
// @Param Authorization header string true "认证令牌"
// @Failure 403 {object} model.Response
// @Router /api/oauth2/affirm [post]
func (ctr *Oauth2) Affirm(ctx *Context) {
	store, err := session.Start(nil, ctx.Writer, ctx.Request)
	if err != nil {
		ctx.Fail(err)
		return
	}

	var form url.Values
	if v, ok := store.Get("ReturnUri"); ok {
		form = v.(url.Values)
	}
	ctx.Request.Form = form
	store.Delete("ReturnUri")
	store.Save()
	err = ctr.OAuth2.HandleAuthorizeRequest(ctx.Writer, ctx.Request)
	if err != nil {
		ctx.Fail(err)
		return
	}
}

// Authorize api implementation
// @Summary 用户授权
// @Tags OAuth授权
// @Param Authorization header string true "认证令牌"
// @Failure 403 {object} model.Response
// @Router /api/oauth2/authorize [get]
func (ctr *Oauth2) Authorize(ctx *Context) {
	store, err := session.Start(nil, ctx.Writer, ctx.Request)
	if err != nil {
		ctx.Fail(err)
		return
	}
	var form url.Values
	if v, ok := store.Get("ReturnUri"); ok {
		form = v.(url.Values)
	}
	ctx.Request.Form = form
	store.Delete("ReturnUri")
	store.Save()
	err = ctr.OAuth2.HandleAuthorizeRequest(ctx.Writer, ctx.Request)
	if err != nil {
		ctx.Fail(err)
		return
	}
}

// Token api implementation
// @Summary 获取令牌
// @Tags OAuth授权
// @Param Authorization header string true "认证令牌"
// @Failure 403 {object} model.Response
// @Router /api/oauth2/token [post]
func (ctr *Oauth2) Token(ctx *Context) {
	err := ctr.OAuth2.HandleTokenRequest(ctx.Writer, ctx.Request)
	if err != nil {
		ctx.Fail(err)
	}
}

// Oauth2 api implementation
// @Summary 授权回调
// @Tags OAuth授权
// @Param Authorization header string true "认证令牌"
// @Failure 403 {object} model.Response
// @Router /api/oauth2/oauth2 [get]
func (ctr *Oauth2) Oauth2(ctx *Context) {
	ctx.Request.ParseForm()
	f := ctx.Request.Form
	state := f.Get("state")
	code := f.Get("code")
	if code == "" {
		ctx.Fail(errors.New("Code not found"))
		return
	}
	ret, err := oa2cfg.Exchange(context.Background(), code)
	if err != nil {
		ctx.Fail(err)
		return
	}
	urlState, err := url.Parse(state)
	if err != nil {
		ctx.Fail(err)
		return
	}
	qState := urlState.Query()
	rawRedirect := qState.Get("redirect_uri")
	rawState := qState.Get("state")
	if strings.TrimSpace(rawRedirect) != "" {
		urlRedirect, err := url.Parse(rawRedirect)
		if err != nil {
			ctx.Fail(err)
			return
		}
		redirect := urlRedirect.Path
		ctx.Redirect(http.StatusFound, redirect+"?state="+rawState)
	} else {
		ctx.Redirect(http.StatusFound, "/?state="+rawState)
	}
	ctx.Success(ret)
}

// URL api implementation
// @Summary 授权地址
// @Tags OAuth授权
// @Param Authorization header string true "认证令牌"
// @Failure 403 {object} model.Response
// @Router /api/oauth2/url [get]
func (ctr *Oauth2) URL(ctx *Context) {
	rawRedirect := ctx.Query("redirect_uri")
	rawState := ctx.Query("state")
	state := "redirect_uri=" + rawRedirect + "&state=" + rawState
	ret := oa2cfg.AuthCodeURL(state)
	ctx.Success(ret)
}

// Refresh api implementation
// @Summary 刷新令牌
// @Tags OAuth授权
// @Param Authorization header string true "认证令牌"
// @Failure 403 {object} model.Response
// @Router /api/oauth2/refresh [get]
func (ctr *Oauth2) Refresh(ctx *Context) {
	refreshtoken, ok := ctr.OAuth2.BearerAuth(ctx.Request)
	if !ok {
		ctx.Fail(oaErrors.ErrInvalidAccessToken)
		return
	}
	token := oauth2.Token{}
	token.Expiry = time.Now()
	token.RefreshToken = refreshtoken
	ret, err := oa2cfg.TokenSource(context.Background(), &token).Token()
	if err != nil {
		ctx.Fail(err)
		return
	}
	ctx.Success(ret)
}
