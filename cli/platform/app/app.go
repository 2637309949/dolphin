// Code generated by dol build. Only Generate by tools if not existed.
// source: app.go

package app

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/2637309949/dolphin/srv"
	"github.com/2637309949/dolphin/srv/cli"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
)

// NewLifeHook create lifecycle hook
func NewLifeHook(e *Engine) srv.Hook {
	http := &http.Server{Addr: fmt.Sprintf(":%v", viper.GetString("port")), Handler: e.Gin}
	return srv.Hook{
		OnStart: func(context.Context) error {
			go func() {
				if err := http.ListenAndServe(); err != nil {
					logrus.Fatal(err)
				}
			}()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			if err := http.Shutdown(ctx); err != nil {
				logrus.Fatal(err)
				return err
			}
			return nil
		},
	}
}

func init() {
	// set logger
	logrus.SetFormatter(&logrus.TextFormatter{
		FullTimestamp:   true,
		TimestampFormat: time.RFC3339,
	})
	// read config
	viper.SetConfigName("app")
	viper.AddConfigPath(".")
	viper.AddConfigPath("conf")
	viper.AutomaticEnv()
	viper.SetDefault("sqlDir", "sql")
	viper.SetDefault("dbType", "mysql")
	viper.SetDefault("port", "8089")
	viper.SetDefault("dbUri", "root:111111@/dolphin?charset=utf8&parseTime=True&loc=Local")
	if err := viper.ReadInConfig(); err != nil {
		logrus.Warn("unable to read config file")
	}
	// lazy init Engine
	var _ = cli.Provider(func(lc srv.Lifecycle) *Engine {
		e := NewEngine()
		lc.Append(NewLifeHook(e))
		return e
	})
}
