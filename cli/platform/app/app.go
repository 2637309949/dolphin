// Code generated by dol build. Only Generate by tools if not existed.
// source: app.go

package app

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"path"
	"strconv"
	"strings"
	"time"

	"github.com/2637309949/dolphin/cli/platform/sql"
	"github.com/2637309949/dolphin/cli/platform/util"
	"github.com/2637309949/dolphin/srv"
	"github.com/2637309949/dolphin/srv/cli"
	method "github.com/bu/gin-method-override"
	nice "github.com/ekyoung/gin-nice-recovery"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
	"github.com/xormplus/xorm"
)

type (
	// Query defined parse struct from query
	Query struct {
		ctx *Context
		m   map[string]interface{}
	}
	// Engine defined parse app engine
	Engine struct {
		Gin           *gin.Engine
		PlatformDB    *xorm.Engine
		BusinessDBSet map[string]*xorm.Engine
	}
	// Context defined http handle hook context
	Context struct {
		*gin.Context
		DB   *xorm.Engine
		User *interface{}
	}
	// HandlerFunc defines the handler used by gin middleware as return value.
	HandlerFunc func(*Context)
	// RouterGroup defines struct that extend from gin.RouterGroup
	RouterGroup struct {
		*gin.RouterGroup
		Engine *Engine
	}
)

// SetInt defined
func (q *Query) SetInt(key string, init ...int) {
	v := q.ctx.Query(key)
	if strings.TrimSpace(v) == "" {
		if len(init) > 0 {
			q.m[key] = init[0]
		} else {
			q.m[key] = 0
		}
	} else {
		i, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			panic(err)
		}
		q.m[key] = i
	}
}

// SetString defined
func (q *Query) SetString(key string, init ...string) {
	v := q.ctx.Query(key)
	if strings.TrimSpace(v) == "" {
		if len(init) > 0 {
			q.m[key] = init[0]
		} else {
			q.m[key] = ""
		}
	} else {
		q.m[key] = v
	}
}

// Value defined
func (q *Query) Value() map[string]interface{} {
	return q.m
}

// Query defined
func (e *Engine) Query(ctx *Context) *Query {
	return &Query{m: util.M{}, ctx: ctx}
}

// PageSearch defined
func (e *Engine) PageSearch(db *xorm.Engine, controller, api, table string, q map[string]interface{}) (interface{}, error) {
	page := q["page"].(int)
	size := q["size"].(int)
	q["offset"] = (page - 1) * size

	sqlTagName := fmt.Sprintf("%s_%s_select.tpl", controller, api)
	result, err := db.SqlTemplateClient(sqlTagName, &q).Query().List()

	if err != nil {
		return nil, err
	}

	sqlTagName = fmt.Sprintf("%s_%s_count.tpl", controller, api)
	cresult, err := db.SqlTemplateClient(sqlTagName, &q).Query().List()
	if err != nil {
		return nil, err
	}

	if result == nil {
		ret := util.M{}
		ret["page"] = page
		ret["size"] = size
		ret["data"] = []interface{}{}
		ret["totalrecords"] = 0
		ret["totalpages"] = 0
		ret[""] = 0
		return &ret, nil
	}

	records := cresult[0]["records"].(int64)
	var totalpages int64 = 0
	// if records < int64(size) {
	if records < int64(size) {
		totalpages = 1
	} else if records%int64(size) == 0 {
		totalpages = records / int64(size)
	} else {
		totalpages = records/int64(size) + 1
	}

	ret := util.M{}
	ret["page"] = page
	ret["size"] = size
	ret["data"] = result
	ret["totalrecords"] = records
	ret["totalpages"] = totalpages
	return &ret, nil
}

// Group handlers
func (e *Engine) Group(relativePath string, handlers ...gin.HandlerFunc) *RouterGroup {
	return &RouterGroup{Engine: e, RouterGroup: e.Gin.Group(relativePath, handlers...)}
}

// Sync2 handlers
func (e *Engine) Sync2(beans ...interface{}) error {
	for _, db := range e.BusinessDBSet {
		db.Sync2(beans...)
	}
	return nil
}

// WithUser defined User
func (ctx *Context) WithUser(user interface{}) {
	if ctx.User != nil {
		*ctx.User = user
	}
	return
}

// HandlerFunc convert to gin.HandlerFunc
func (h HandlerFunc) HandlerFunc(e *Engine) gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		c := &Context{Context: ctx}
		// with user
		c.WithUser(nil)
		// find db by PlatformDB
		c.DB = e.PlatformDB
		h(c)
	})
}

// Handle overwrite RouterGroup.Handle
func (rg *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) gin.IRoutes {
	var newHandlers []gin.HandlerFunc
	for _, h := range handlers {
		newHandlers = append(newHandlers, h.HandlerFunc(rg.Engine))
	}
	return rg.RouterGroup.Handle(httpMethod, relativePath, newHandlers...)
}

// NewLifeHook create lifecycle hook
func NewLifeHook(e *Engine) srv.Hook {
	http := &http.Server{Addr: fmt.Sprintf(":%v", viper.GetString("port")), Handler: e.Gin}
	return srv.Hook{
		OnStart: func(context.Context) error {
			go func() {
				if err := http.ListenAndServe(); err != nil {
					logrus.Fatal(err)
				}
			}()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			if err := http.Shutdown(ctx); err != nil {
				logrus.Fatal(err)
				return err
			}
			return nil
		},
	}
}

// NewEngine init Engine
func NewEngine() *Engine {
	var err error
	// set logger
	logrus.SetFormatter(&logrus.TextFormatter{
		FullTimestamp:   true,
		TimestampFormat: time.RFC3339,
	})

	// read config
	viper.SetConfigName("app")
	viper.AddConfigPath(".")
	viper.AddConfigPath("conf")
	viper.AutomaticEnv()
	viper.SetDefault("sqlDir", "sql")
	viper.SetDefault("dbType", "mysql")
	viper.SetDefault("port", "8089")
	viper.SetDefault("dbUri", "root:111111@/dolphin?charset=utf8&parseTime=True&loc=Local")
	if err = viper.ReadInConfig(); err != nil {
		logrus.Warn("unable to read config file")
	}

	// init xorm
	e := &Engine{}
	e.PlatformDB, err = xorm.NewEngine(viper.GetString("dbType"), viper.GetString("dbUri"))
	if err != nil {
		logrus.Fatal(err)
	}
	if err = e.PlatformDB.Ping(); err != nil {
		logrus.Fatal(err)
	}
	xLogger := xorm.NewSimpleLogger(logrus.StandardLogger().Out)
	xLogger.ShowSQL(true)
	e.PlatformDB.SetLogger(xLogger)
	// RegisterSqlMap
	sqlDir := path.Join(".", viper.GetString("sqlDir"))
	if err = os.MkdirAll(sqlDir, os.ModePerm); err != nil {
		logrus.Fatal(err)
	}
	if err = e.PlatformDB.RegisterSqlMap(xorm.Xml(sqlDir, ".xml")); err != nil {
		logrus.Fatal(err)
	}
	if err = e.PlatformDB.RegisterSqlTemplate(xorm.Pongo2(sqlDir, ".stpl")); err != nil {
		logrus.Fatal(err)
	}
	if err = e.PlatformDB.RegisterSqlTemplate(xorm.Jet(sqlDir, ".jet")); err != nil {
		logrus.Fatal(err)
	}
	if err = e.PlatformDB.RegisterSqlTemplate(xorm.Default(sqlDir, ".tpl")); err != nil {
		logrus.Fatal(err)
	}
	for k, v := range sql.SQLTPL {
		logrus.Info(k, v)
		if err = e.PlatformDB.AddSqlTemplate(k, v); err != nil {
			logrus.Fatal(err)
		}
	}

	// init gin
	gin.SetMode(gin.ReleaseMode)
	e.Gin = gin.New()
	e.Gin.Use(gin.Logger())
	e.Gin.Use(nice.Recovery(func(ctx *gin.Context, err interface{}) {
		code := 500
		if err, ok := err.(util.Error); ok {
			code = err.Code
		}
		ctx.JSON(http.StatusInternalServerError, util.M{"code": code, "message": err})
	}))
	e.Gin.Use(method.ProcessMethodOverride(e.Gin))
	return e
}

// lazy init Engine
var _ = cli.Provider(func(lc srv.Lifecycle) *Engine {
	e := NewEngine()
	lc.Append(NewLifeHook(e))
	return e
})
