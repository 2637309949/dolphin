// Code generated by dol build. Only Generate by tools if not existed.
// source: app.go

package app

import (
	"context"
	"example/utils"
	"fmt"
	"net/http"
	"os"
	"path"
	"strconv"
	"strings"

	dol "github.com/2637309949/dolphin/srv"
	"github.com/2637309949/dolphin/srv/cli"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
	"github.com/xormplus/xorm"
)

// Engine struct
type Engine struct {
	Gin  *gin.Engine
	Xorm *xorm.Engine
}

// Query struct
type Query struct {
	m   utils.M
	ctx *Context
}

// SetInt defined
func (q *Query) SetInt(key string, init ...int) {
	v := q.ctx.Query(key)
	if strings.TrimSpace(v) == "" {
		if len(init) > 0 {
			q.m[key] = init[0]
		} else {
			q.m[key] = 0
		}
	} else {
		i, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			panic(err)
		}
		q.m[key] = i
	}
}

// SetString defined
func (q *Query) SetString(key string, init ...string) {
	v := q.ctx.Query(key)
	if strings.TrimSpace(v) == "" {
		if len(init) > 0 {
			q.m[key] = init[0]
		} else {
			q.m[key] = ""
		}
	} else {
		q.m[key] = v
	}
}

// Value defined
func (q *Query) Value() *utils.M {
	return &q.m
}

// Query defined
func (e *Engine) Query(ctx *Context) *Query {
	return &Query{m: utils.M{}, ctx: ctx}
}

// PageSearch defined
func (e *Engine) PageSearch(controller, api, table string, q *utils.M) (interface{}, error) {
	page := (*q)["page"].(int)
	size := (*q)["size"].(int)
	(*q)["offset"] = (page - 1) * size

	sqlTagName := fmt.Sprintf("%s_%s_select.tpl", controller, api)
	result, err := e.Xorm.SqlTemplateClient(sqlTagName, q).Query().List()
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	sqlTagName = fmt.Sprintf("%s_%s_count.tpl", controller, api)
	cresult, err := e.Xorm.SqlTemplateClient(sqlTagName, &q).Query().List()
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	if result == nil {
		ret := utils.M{}
		ret["page"] = page
		ret["size"] = size
		ret["data"] = []interface{}{}
		ret["totalrecords"] = 0
		ret["totalpages"] = 0
		ret[""] = 0
		return &ret, nil
	}

	records := cresult[0]["records"].(int64)
	var totalpages int64 = 0
	if records < int64(size) {
		totalpages = 1
	} else if records%int64(size) == 0 {
		totalpages = records / int64(size)
	} else {
		totalpages = records/int64(size) + 1
	}
	ret := utils.M{}
	ret["page"] = page
	ret["size"] = size
	ret["data"] = result
	ret["totalrecords"] = records
	ret["totalpages"] = totalpages
	return &ret, nil
}

// Group handlers
func (e *Engine) Group(relativePath string, handlers ...gin.HandlerFunc) *RouterGroup {
	gp := e.Gin.Group(relativePath, handlers...)
	rg := &RouterGroup{gp}
	return rg
}

// Sync2 handlers
func (e *Engine) Sync2(beans ...interface{}) error {
	return e.Xorm.Sync2(beans...)
}

// Context struct
type Context struct {
	*gin.Context
}

// HandlerFunc defines the handler used by gin middleware as return value.
type HandlerFunc func(*Context)

// HandlerFunc convert to gin.HandlerFunc
func (h HandlerFunc) HandlerFunc() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		c := &Context{Context: ctx}
		h(c)
	})
}

// RouterGroup struct
type RouterGroup struct {
	*gin.RouterGroup
}

// Handle overwrite RouterGroup.Handle
func (rg *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) gin.IRoutes {
	var newHandlers []gin.HandlerFunc
	for _, h := range handlers {
		newHandlers = append(newHandlers, h.HandlerFunc())
	}
	return rg.RouterGroup.Handle(httpMethod, relativePath, newHandlers...)
}

func init() {
	cli.Provider(func(lc dol.Lifecycle) *Engine {
		Xorm, err := xorm.NewEngine("mysql", "root:111111@/dolphin?charset=utf8&parseTime=True&loc=Local")
		if err != nil {
			logrus.Fatal(err)
		}
		if err = Xorm.Ping(); err != nil {
			logrus.Fatal(err)
		}
		if err = os.MkdirAll(path.Join(".", "sql"), os.ModePerm); err != nil {
			logrus.Fatal(err)
		}
		err = Xorm.RegisterSqlMap(xorm.Xml(path.Join(".", "sql"), ".xml"))
		if err != nil {
			logrus.Fatal(err)
		}
		engine := &Engine{}
		engine.Gin = gin.New()
		engine.Xorm = Xorm
		http := &http.Server{Addr: fmt.Sprintf(":%v", "8091"), Handler: engine.Gin}
		lc.Append(dol.Hook{
			OnStart: func(context.Context) error {
				go func() {
					if err = http.ListenAndServe(); err != nil {
						logrus.Fatal(err)
					}
				}()
				return nil
			},
			OnStop: func(ctx context.Context) error {
				if err = http.Shutdown(ctx); err != nil {
					logrus.Fatal(err)
					return err
				}
				return nil
			},
		})
		return engine
	})
}
